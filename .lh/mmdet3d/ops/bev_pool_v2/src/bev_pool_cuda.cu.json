{
    "sourceFile": "mmdet3d/ops/bev_pool_v2/src/bev_pool_cuda.cu",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1720924584109,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1720924584109,
            "name": "Commit-0",
            "content": "// Copyright (c) Phigent Robotics. All rights reserved.\n// Reference https://arxiv.org/abs/2211.17111\n\n#include <stdio.h>\n#include <stdlib.h>\n\n/*\n  Function: pillar pooling\n  Args:\n    c                : number of channels\n    n_intervals      : number of unique points\n    depth            : input depth, FloatTensor[b,n,d,h,w]\n    feat             : input feat, FloatTensor[b,n,h,w,c]\n    ranks_depth      : input index of depth, IntTensor[n]\n    ranks_feat       : input index of feat, IntTensor[n]\n    ranks_bev        : output index, IntTensor[n]\n    interval_lengths : starting position for pooled point, IntTensor[n_intervals]\n    interval_starts  : how many points in each pooled point, IntTensor[n_intervals]\n    out              : output features, FloatTensor[b, d, h, w, c]\n*/\n__global__ void bev_pool_v2_kernel(int c, int n_intervals,\n                                  const float *__restrict__ depth,\n                                  const float *__restrict__ feat,\n                                  const int *__restrict__ ranks_depth,\n                                  const int *__restrict__ ranks_feat,\n                                  const int *__restrict__ ranks_bev,\n                                  const int *__restrict__ interval_starts,\n                                  const int *__restrict__ interval_lengths,\n                                  float* __restrict__ out) {\n  int idx = blockIdx.x * blockDim.x + threadIdx.x;\n  int index = idx / c;\n  int cur_c = idx % c;\n  if (index >= n_intervals) return;\n  int interval_start = interval_starts[index];\n  int interval_length = interval_lengths[index];\n  float psum = 0;\n  const float* cur_depth;\n  const float* cur_feat;\n  for(int i = 0; i < interval_length; i++){\n    cur_depth = depth + ranks_depth[interval_start+i];\n    cur_feat = feat + ranks_feat[interval_start+i] * c + cur_c;\n    psum += *cur_feat * *cur_depth;\n  }\n\n  const int* cur_rank = ranks_bev + interval_start;\n  float* cur_out = out + *cur_rank * c + cur_c;\n  *cur_out = psum;\n}\n\n\n/*\n  Function: pillar pooling backward\n  Args:\n    c                : number of channels\n    n_intervals      : number of unique points\n    out_grad         : gradient of the BEV fmap from top, FloatTensor[b, d, h, w, c]\n    depth            : input depth, FloatTensor[b,n,d,h,w]\n    feat             : input feat, FloatTensor[b,n,h,w,c]\n    ranks_depth      : input index of depth, IntTensor[n]\n    ranks_feat       : input index of feat, IntTensor[n]\n    ranks_bev        : output index, IntTensor[n]\n    interval_lengths : starting position for pooled point, IntTensor[n_intervals]\n    interval_starts  : how many points in each pooled point, IntTensor[n_intervals]\n    depth_grad       : gradient of the depth fmap, FloatTensor\n    feat_grad        : gradient of the feature fmap, FloatTensor\n*/\n__global__ void bev_pool_grad_kernel(int c, int n_intervals,\n                                  const float *__restrict__ out_grad,\n                                  const float *__restrict__ depth,\n                                  const float *__restrict__ feat,\n                                  const int *__restrict__ ranks_depth,\n                                  const int *__restrict__ ranks_feat,\n                                  const int *__restrict__ ranks_bev,\n                                  const int *__restrict__ interval_starts,\n                                  const int *__restrict__ interval_lengths,\n                                  float* __restrict__ depth_grad,\n                                  float* __restrict__ feat_grad) {\n  int idx = blockIdx.x * blockDim.x + threadIdx.x;\n  if (idx >= n_intervals) return;\n  int interval_start = interval_starts[idx];\n  int interval_length = interval_lengths[idx];\n\n  const int* cur_rank;\n  const float* cur_out_grad;\n  const float* cur_out_grad_start;\n\n  const float* cur_feat;\n  const float* cur_feat_start;\n  float* cur_depth_grad;\n  float grad_sum;\n  for(int i = 0; i < interval_length; i++){\n    cur_rank = ranks_bev + interval_start + i;\n    cur_out_grad_start = out_grad +  * cur_rank * c;\n    cur_feat_start = feat + ranks_feat[interval_start+i] * c;\n\n    grad_sum = 0;\n    for(int cur_c = 0; cur_c < c; cur_c++){\n      cur_out_grad = cur_out_grad_start + cur_c;\n      cur_feat = cur_feat_start + cur_c;\n      grad_sum += *cur_out_grad * *cur_feat;\n    }\n\n    cur_depth_grad = depth_grad + ranks_depth[interval_start+i];\n    *cur_depth_grad = grad_sum;\n  }\n\n  float* cur_feat_grad;\n  const float* cur_depth;\n  for(int cur_c = 0; cur_c < c; cur_c++){\n    grad_sum = 0;\n    for(int i = 0; i < interval_length; i++){\n      cur_rank = ranks_bev + interval_start + i;\n      cur_out_grad = out_grad + *cur_rank * c + cur_c;\n\n      cur_depth = depth + ranks_depth[interval_start+i];\n      grad_sum += *cur_out_grad * *cur_depth;\n    }\n    cur_feat_grad = feat_grad + ranks_feat[interval_start] * c + cur_c ;\n    * cur_feat_grad = grad_sum;\n  }\n}\n\n\n\nvoid bev_pool_v2(int c, int n_intervals, const float* depth, const float* feat, const int* ranks_depth,\n  const int* ranks_feat, const int* ranks_bev, const int* interval_starts, const int* interval_lengths, float* out) {\n  bev_pool_v2_kernel<<<(int)ceil(((double)n_intervals * c / 256)), 256>>>(\n    c, n_intervals, depth, feat, ranks_depth, ranks_feat,\n    ranks_bev, interval_starts, interval_lengths, out\n  );\n}\n\nvoid bev_pool_v2_grad(int c, int n_intervals, const float* out_grad,\n  const float* depth, const float* feat, const int* ranks_depth, const int* ranks_feat,\n  const int* ranks_bev, const int* interval_starts, const int* interval_lengths, float* depth_grad, float* feat_grad) {\n  bev_pool_grad_kernel<<<(int)ceil(((double)n_intervals / 256)), 256>>>(\n     c, n_intervals, out_grad, depth, feat, ranks_depth, ranks_feat,\n     ranks_bev, interval_starts, interval_lengths, depth_grad, feat_grad\n  );\n}\n"
        }
    ]
}