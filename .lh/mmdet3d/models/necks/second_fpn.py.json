{
    "sourceFile": "mmdet3d/models/necks/second_fpn.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1724749418006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1724749418006,
            "name": "Commit-0",
            "content": "# Copyright (c) OpenMMLab. All rights reserved.\nimport numpy as np\nimport torch\nfrom mmcv.cnn import build_conv_layer, build_norm_layer, build_upsample_layer\nfrom mmcv.runner import BaseModule, auto_fp16\nfrom torch import nn as nn\n\nfrom ..builder import NECKS\n\n\n@NECKS.register_module()\nclass SECONDFPN(BaseModule):\n    \"\"\"FPN used in SECOND/PointPillars/PartA2/MVXNet.\n\n    Args:\n        in_channels (list[int]): Input channels of multi-scale feature maps.\n        out_channels (list[int]): Output channels of feature maps.\n        upsample_strides (list[int]): Strides used to upsample the\n            feature maps.\n        norm_cfg (dict): Config dict of normalization layers.\n        upsample_cfg (dict): Config dict of upsample layers.\n        conv_cfg (dict): Config dict of conv layers.\n        use_conv_for_no_stride (bool): Whether to use conv when stride is 1.\n    \"\"\"\n\n    def __init__(self,\n                 in_channels=[128, 128, 256],\n                 out_channels=[256, 256, 256],\n                 upsample_strides=[1, 2, 4],\n                 norm_cfg=dict(type='BN', eps=1e-3, momentum=0.01),\n                 upsample_cfg=dict(type='deconv', bias=False),\n                 conv_cfg=dict(type='Conv2d', bias=False),\n                 use_conv_for_no_stride=False,\n                 init_cfg=None):\n        # if for GroupNorm,\n        # cfg is dict(type='GN', num_groups=num_groups, eps=1e-3, affine=True)\n        super(SECONDFPN, self).__init__(init_cfg=init_cfg)\n        assert len(out_channels) == len(upsample_strides) == len(in_channels)\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.fp16_enabled = False\n\n        deblocks = []\n        for i, out_channel in enumerate(out_channels):\n            stride = upsample_strides[i]\n            if stride > 1 or (stride == 1 and not use_conv_for_no_stride):\n                upsample_layer = build_upsample_layer(\n                    upsample_cfg,\n                    in_channels=in_channels[i],\n                    out_channels=out_channel,\n                    kernel_size=upsample_strides[i],\n                    stride=upsample_strides[i])\n            else:\n                stride = np.round(1 / stride).astype(np.int64)\n                upsample_layer = build_conv_layer(\n                    conv_cfg,\n                    in_channels=in_channels[i],\n                    out_channels=out_channel,\n                    kernel_size=stride,\n                    stride=stride)\n\n            deblock = nn.Sequential(upsample_layer,\n                                    build_norm_layer(norm_cfg, out_channel)[1],\n                                    nn.ReLU(inplace=True))\n            deblocks.append(deblock)\n        self.deblocks = nn.ModuleList(deblocks)\n\n        if init_cfg is None:\n            self.init_cfg = [\n                dict(type='Kaiming', layer='ConvTranspose2d'),\n                dict(type='Constant', layer='NaiveSyncBatchNorm2d', val=1.0)\n            ]\n\n    @auto_fp16()\n    def forward(self, x):\n        \"\"\"Forward function.\n\n        Args:\n            x (torch.Tensor): 4D Tensor in (N, C, H, W) shape.\n\n        Returns:\n            list[torch.Tensor]: Multi-level feature maps.\n        \"\"\"\n        assert len(x) == len(self.in_channels)\n        ups = [deblock(x[i]) for i, deblock in enumerate(self.deblocks)]\n\n        if len(ups) > 1:\n            out = torch.cat(ups, dim=1)\n        else:\n            out = ups[0]\n        return [out]\n"
        }
    ]
}