{
    "sourceFile": "mmdet3d/models/detectors/centerpoint.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1716367880582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1716470100269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,8 +76,9 @@\n         \"\"\"\n         outs = self.pts_bbox_head(pts_feats)\n         loss_inputs = [gt_bboxes_3d, gt_labels_3d, outs]\n         losses = self.pts_bbox_head.loss(*loss_inputs)\n+        \n         return losses\n \n     def simple_test_pts(self, x, img_metas, rescale=False):\n         \"\"\"Test function of point cloud branch.\"\"\"\n"
                },
                {
                    "date": 1716470100966,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,36 +9,48 @@\n @DETECTORS.register_module()\n class CenterPoint(MVXTwoStageDetector):\n     \"\"\"Base class of Multi-modality VoxelNet.\"\"\"\n \n-    def __init__(self,\n-                 pts_voxel_layer=None,\n-                 pts_voxel_encoder=None,\n-                 pts_middle_encoder=None,\n-                 pts_fusion_layer=None,\n-                 img_backbone=None,\n-                 pts_backbone=None,\n-                 img_neck=None,\n-                 pts_neck=None,\n-                 pts_bbox_head=None,\n-                 img_roi_head=None,\n-                 img_rpn_head=None,\n-                 train_cfg=None,\n-                 test_cfg=None,\n-                 pretrained=None,\n-                 init_cfg=None):\n-        super(CenterPoint,\n-              self).__init__(pts_voxel_layer, pts_voxel_encoder,\n-                             pts_middle_encoder, pts_fusion_layer,\n-                             img_backbone, pts_backbone, img_neck, pts_neck,\n-                             pts_bbox_head, img_roi_head, img_rpn_head,\n-                             train_cfg, test_cfg, pretrained, init_cfg)\n+    def __init__(\n+        self,\n+        pts_voxel_layer=None,\n+        pts_voxel_encoder=None,\n+        pts_middle_encoder=None,\n+        pts_fusion_layer=None,\n+        img_backbone=None,\n+        pts_backbone=None,\n+        img_neck=None,\n+        pts_neck=None,\n+        pts_bbox_head=None,\n+        img_roi_head=None,\n+        img_rpn_head=None,\n+        train_cfg=None,\n+        test_cfg=None,\n+        pretrained=None,\n+        init_cfg=None,\n+    ):\n+        super(CenterPoint, self).__init__(\n+            pts_voxel_layer,\n+            pts_voxel_encoder,\n+            pts_middle_encoder,\n+            pts_fusion_layer,\n+            img_backbone,\n+            pts_backbone,\n+            img_neck,\n+            pts_neck,\n+            pts_bbox_head,\n+            img_roi_head,\n+            img_rpn_head,\n+            train_cfg,\n+            test_cfg,\n+            pretrained,\n+            init_cfg,\n+        )\n \n     @property\n     def with_velocity(self):\n         \"\"\"bool: Whether the head predicts velocity\"\"\"\n-        return self.pts_bbox_head is not None and \\\n-            self.pts_bbox_head.with_velocity\n+        return self.pts_bbox_head is not None and self.pts_bbox_head.with_velocity\n \n     def extract_pts_feat(self, pts, img_feats, img_metas):\n         \"\"\"Extract features of points.\"\"\"\n         if not self.with_pts_bbox:\n@@ -52,14 +64,11 @@\n         if self.with_pts_neck:\n             x = self.pts_neck(x)\n         return x\n \n-    def forward_pts_train(self,\n-                          pts_feats,\n-                          gt_bboxes_3d,\n-                          gt_labels_3d,\n-                          img_metas,\n-                          gt_bboxes_ignore=None):\n+    def forward_pts_train(\n+        self, pts_feats, gt_bboxes_3d, gt_labels_3d, img_metas, gt_bboxes_ignore=None\n+    ):\n         \"\"\"Forward function for point cloud branch.\n \n         Args:\n             pts_feats (list[torch.Tensor]): Features of point cloud branch\n@@ -76,16 +85,15 @@\n         \"\"\"\n         outs = self.pts_bbox_head(pts_feats)\n         loss_inputs = [gt_bboxes_3d, gt_labels_3d, outs]\n         losses = self.pts_bbox_head.loss(*loss_inputs)\n-        \n+\n         return losses\n \n     def simple_test_pts(self, x, img_metas, rescale=False):\n         \"\"\"Test function of point cloud branch.\"\"\"\n         outs = self.pts_bbox_head(x)\n-        bbox_list = self.pts_bbox_head.get_bboxes(\n-            outs, img_metas, rescale=rescale)\n+        bbox_list = self.pts_bbox_head.get_bboxes(outs, img_metas, rescale=rescale)\n         bbox_results = [\n             bbox3d2result(bboxes, scores, labels)\n             for bboxes, scores, labels in bbox_list\n         ]\n@@ -120,78 +128,84 @@\n             outs = self.pts_bbox_head(x)\n             # merge augmented outputs before decoding bboxes\n             for task_id, out in enumerate(outs):\n                 for key in out[0].keys():\n-                    if img_meta[0]['pcd_horizontal_flip']:\n+                    if img_meta[0][\"pcd_horizontal_flip\"]:\n                         outs[task_id][0][key] = torch.flip(\n-                            outs[task_id][0][key], dims=[2])\n-                        if key == 'reg':\n-                            outs[task_id][0][key][:, 1, ...] = 1 - outs[\n-                                task_id][0][key][:, 1, ...]\n-                        elif key == 'rot':\n-                            outs[task_id][0][\n-                                key][:, 0,\n-                                     ...] = -outs[task_id][0][key][:, 0, ...]\n-                        elif key == 'vel':\n-                            outs[task_id][0][\n-                                key][:, 1,\n-                                     ...] = -outs[task_id][0][key][:, 1, ...]\n-                    if img_meta[0]['pcd_vertical_flip']:\n+                            outs[task_id][0][key], dims=[2]\n+                        )\n+                        if key == \"reg\":\n+                            outs[task_id][0][key][:, 1, ...] = (\n+                                1 - outs[task_id][0][key][:, 1, ...]\n+                            )\n+                        elif key == \"rot\":\n+                            outs[task_id][0][key][:, 0, ...] = -outs[task_id][0][key][\n+                                :, 0, ...\n+                            ]\n+                        elif key == \"vel\":\n+                            outs[task_id][0][key][:, 1, ...] = -outs[task_id][0][key][\n+                                :, 1, ...\n+                            ]\n+                    if img_meta[0][\"pcd_vertical_flip\"]:\n                         outs[task_id][0][key] = torch.flip(\n-                            outs[task_id][0][key], dims=[3])\n-                        if key == 'reg':\n-                            outs[task_id][0][key][:, 0, ...] = 1 - outs[\n-                                task_id][0][key][:, 0, ...]\n-                        elif key == 'rot':\n-                            outs[task_id][0][\n-                                key][:, 1,\n-                                     ...] = -outs[task_id][0][key][:, 1, ...]\n-                        elif key == 'vel':\n-                            outs[task_id][0][\n-                                key][:, 0,\n-                                     ...] = -outs[task_id][0][key][:, 0, ...]\n+                            outs[task_id][0][key], dims=[3]\n+                        )\n+                        if key == \"reg\":\n+                            outs[task_id][0][key][:, 0, ...] = (\n+                                1 - outs[task_id][0][key][:, 0, ...]\n+                            )\n+                        elif key == \"rot\":\n+                            outs[task_id][0][key][:, 1, ...] = -outs[task_id][0][key][\n+                                :, 1, ...\n+                            ]\n+                        elif key == \"vel\":\n+                            outs[task_id][0][key][:, 0, ...] = -outs[task_id][0][key][\n+                                :, 0, ...\n+                            ]\n \n             outs_list.append(outs)\n \n         preds_dicts = dict()\n         scale_img_metas = []\n \n         # concat outputs sharing the same pcd_scale_factor\n         for i, (img_meta, outs) in enumerate(zip(img_metas, outs_list)):\n-            pcd_scale_factor = img_meta[0]['pcd_scale_factor']\n+            pcd_scale_factor = img_meta[0][\"pcd_scale_factor\"]\n             if pcd_scale_factor not in preds_dicts.keys():\n                 preds_dicts[pcd_scale_factor] = outs\n                 scale_img_metas.append(img_meta)\n             else:\n                 for task_id, out in enumerate(outs):\n                     for key in out[0].keys():\n-                        preds_dicts[pcd_scale_factor][task_id][0][key] += out[\n-                            0][key]\n+                        preds_dicts[pcd_scale_factor][task_id][0][key] += out[0][key]\n \n         aug_bboxes = []\n \n         for pcd_scale_factor, preds_dict in preds_dicts.items():\n             for task_id, pred_dict in enumerate(preds_dict):\n                 # merge outputs with different flips before decoding bboxes\n                 for key in pred_dict[0].keys():\n                     preds_dict[task_id][0][key] /= len(outs_list) / len(\n-                        preds_dicts.keys())\n+                        preds_dicts.keys()\n+                    )\n             bbox_list = self.pts_bbox_head.get_bboxes(\n-                preds_dict, img_metas[0], rescale=rescale)\n+                preds_dict, img_metas[0], rescale=rescale\n+            )\n             bbox_list = [\n                 dict(boxes_3d=bboxes, scores_3d=scores, labels_3d=labels)\n                 for bboxes, scores, labels in bbox_list\n             ]\n             aug_bboxes.append(bbox_list[0])\n \n         if len(preds_dicts.keys()) > 1:\n             # merge outputs with different scales after decoding bboxes\n-            merged_bboxes = merge_aug_bboxes_3d(aug_bboxes, scale_img_metas,\n-                                                self.pts_bbox_head.test_cfg)\n+            merged_bboxes = merge_aug_bboxes_3d(\n+                aug_bboxes, scale_img_metas, self.pts_bbox_head.test_cfg\n+            )\n             return merged_bboxes\n         else:\n             for key in bbox_list[0].keys():\n-                bbox_list[0][key] = bbox_list[0][key].to('cpu')\n+                bbox_list[0][key] = bbox_list[0][key].to(\"cpu\")\n             return bbox_list[0]\n \n     def aug_test(self, points, img_metas, imgs=None, rescale=False):\n         \"\"\"Test function with augmentaiton.\"\"\"\n"
                },
                {
                    "date": 1718524551747,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,8 +90,10 @@\n         return losses\n \n     def simple_test_pts(self, x, img_metas, rescale=False):\n         \"\"\"Test function of point cloud branch.\"\"\"\n+\n+        \n         outs = self.pts_bbox_head(x)\n         bbox_list = self.pts_bbox_head.get_bboxes(outs, img_metas, rescale=rescale)\n         bbox_results = [\n             bbox3d2result(bboxes, scores, labels)\n"
                },
                {
                    "date": 1740707787152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,9 +91,8 @@\n \n     def simple_test_pts(self, x, img_metas, rescale=False):\n         \"\"\"Test function of point cloud branch.\"\"\"\n \n-        \n         outs = self.pts_bbox_head(x)\n         bbox_list = self.pts_bbox_head.get_bboxes(outs, img_metas, rescale=rescale)\n         bbox_results = [\n             bbox3d2result(bboxes, scores, labels)\n"
                }
            ],
            "date": 1716367880582,
            "name": "Commit-0",
            "content": "# Copyright (c) OpenMMLab. All rights reserved.\nimport torch\n\nfrom mmdet3d.core import bbox3d2result, merge_aug_bboxes_3d\nfrom ..builder import DETECTORS\nfrom .mvx_two_stage import MVXTwoStageDetector\n\n\n@DETECTORS.register_module()\nclass CenterPoint(MVXTwoStageDetector):\n    \"\"\"Base class of Multi-modality VoxelNet.\"\"\"\n\n    def __init__(self,\n                 pts_voxel_layer=None,\n                 pts_voxel_encoder=None,\n                 pts_middle_encoder=None,\n                 pts_fusion_layer=None,\n                 img_backbone=None,\n                 pts_backbone=None,\n                 img_neck=None,\n                 pts_neck=None,\n                 pts_bbox_head=None,\n                 img_roi_head=None,\n                 img_rpn_head=None,\n                 train_cfg=None,\n                 test_cfg=None,\n                 pretrained=None,\n                 init_cfg=None):\n        super(CenterPoint,\n              self).__init__(pts_voxel_layer, pts_voxel_encoder,\n                             pts_middle_encoder, pts_fusion_layer,\n                             img_backbone, pts_backbone, img_neck, pts_neck,\n                             pts_bbox_head, img_roi_head, img_rpn_head,\n                             train_cfg, test_cfg, pretrained, init_cfg)\n\n    @property\n    def with_velocity(self):\n        \"\"\"bool: Whether the head predicts velocity\"\"\"\n        return self.pts_bbox_head is not None and \\\n            self.pts_bbox_head.with_velocity\n\n    def extract_pts_feat(self, pts, img_feats, img_metas):\n        \"\"\"Extract features of points.\"\"\"\n        if not self.with_pts_bbox:\n            return None\n        voxels, num_points, coors = self.voxelize(pts)\n\n        voxel_features = self.pts_voxel_encoder(voxels, num_points, coors)\n        batch_size = coors[-1, 0] + 1\n        x = self.pts_middle_encoder(voxel_features, coors, batch_size)\n        x = self.pts_backbone(x)\n        if self.with_pts_neck:\n            x = self.pts_neck(x)\n        return x\n\n    def forward_pts_train(self,\n                          pts_feats,\n                          gt_bboxes_3d,\n                          gt_labels_3d,\n                          img_metas,\n                          gt_bboxes_ignore=None):\n        \"\"\"Forward function for point cloud branch.\n\n        Args:\n            pts_feats (list[torch.Tensor]): Features of point cloud branch\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\n                boxes for each sample.\n            gt_labels_3d (list[torch.Tensor]): Ground truth labels for\n                boxes of each sampole\n            img_metas (list[dict]): Meta information of samples.\n            gt_bboxes_ignore (list[torch.Tensor], optional): Ground truth\n                boxes to be ignored. Defaults to None.\n\n        Returns:\n            dict: Losses of each branch.\n        \"\"\"\n        outs = self.pts_bbox_head(pts_feats)\n        loss_inputs = [gt_bboxes_3d, gt_labels_3d, outs]\n        losses = self.pts_bbox_head.loss(*loss_inputs)\n        return losses\n\n    def simple_test_pts(self, x, img_metas, rescale=False):\n        \"\"\"Test function of point cloud branch.\"\"\"\n        outs = self.pts_bbox_head(x)\n        bbox_list = self.pts_bbox_head.get_bboxes(\n            outs, img_metas, rescale=rescale)\n        bbox_results = [\n            bbox3d2result(bboxes, scores, labels)\n            for bboxes, scores, labels in bbox_list\n        ]\n        return bbox_results\n\n    def aug_test_pts(self, feats, img_metas, rescale=False):\n        \"\"\"Test function of point cloud branch with augmentaiton.\n\n        The function implementation process is as follows:\n\n            - step 1: map features back for double-flip augmentation.\n            - step 2: merge all features and generate boxes.\n            - step 3: map boxes back for scale augmentation.\n            - step 4: merge results.\n\n        Args:\n            feats (list[torch.Tensor]): Feature of point cloud.\n            img_metas (list[dict]): Meta information of samples.\n            rescale (bool, optional): Whether to rescale bboxes.\n                Default: False.\n\n        Returns:\n            dict: Returned bboxes consists of the following keys:\n\n                - boxes_3d (:obj:`LiDARInstance3DBoxes`): Predicted bboxes.\n                - scores_3d (torch.Tensor): Scores of predicted boxes.\n                - labels_3d (torch.Tensor): Labels of predicted boxes.\n        \"\"\"\n        # only support aug_test for one sample\n        outs_list = []\n        for x, img_meta in zip(feats, img_metas):\n            outs = self.pts_bbox_head(x)\n            # merge augmented outputs before decoding bboxes\n            for task_id, out in enumerate(outs):\n                for key in out[0].keys():\n                    if img_meta[0]['pcd_horizontal_flip']:\n                        outs[task_id][0][key] = torch.flip(\n                            outs[task_id][0][key], dims=[2])\n                        if key == 'reg':\n                            outs[task_id][0][key][:, 1, ...] = 1 - outs[\n                                task_id][0][key][:, 1, ...]\n                        elif key == 'rot':\n                            outs[task_id][0][\n                                key][:, 0,\n                                     ...] = -outs[task_id][0][key][:, 0, ...]\n                        elif key == 'vel':\n                            outs[task_id][0][\n                                key][:, 1,\n                                     ...] = -outs[task_id][0][key][:, 1, ...]\n                    if img_meta[0]['pcd_vertical_flip']:\n                        outs[task_id][0][key] = torch.flip(\n                            outs[task_id][0][key], dims=[3])\n                        if key == 'reg':\n                            outs[task_id][0][key][:, 0, ...] = 1 - outs[\n                                task_id][0][key][:, 0, ...]\n                        elif key == 'rot':\n                            outs[task_id][0][\n                                key][:, 1,\n                                     ...] = -outs[task_id][0][key][:, 1, ...]\n                        elif key == 'vel':\n                            outs[task_id][0][\n                                key][:, 0,\n                                     ...] = -outs[task_id][0][key][:, 0, ...]\n\n            outs_list.append(outs)\n\n        preds_dicts = dict()\n        scale_img_metas = []\n\n        # concat outputs sharing the same pcd_scale_factor\n        for i, (img_meta, outs) in enumerate(zip(img_metas, outs_list)):\n            pcd_scale_factor = img_meta[0]['pcd_scale_factor']\n            if pcd_scale_factor not in preds_dicts.keys():\n                preds_dicts[pcd_scale_factor] = outs\n                scale_img_metas.append(img_meta)\n            else:\n                for task_id, out in enumerate(outs):\n                    for key in out[0].keys():\n                        preds_dicts[pcd_scale_factor][task_id][0][key] += out[\n                            0][key]\n\n        aug_bboxes = []\n\n        for pcd_scale_factor, preds_dict in preds_dicts.items():\n            for task_id, pred_dict in enumerate(preds_dict):\n                # merge outputs with different flips before decoding bboxes\n                for key in pred_dict[0].keys():\n                    preds_dict[task_id][0][key] /= len(outs_list) / len(\n                        preds_dicts.keys())\n            bbox_list = self.pts_bbox_head.get_bboxes(\n                preds_dict, img_metas[0], rescale=rescale)\n            bbox_list = [\n                dict(boxes_3d=bboxes, scores_3d=scores, labels_3d=labels)\n                for bboxes, scores, labels in bbox_list\n            ]\n            aug_bboxes.append(bbox_list[0])\n\n        if len(preds_dicts.keys()) > 1:\n            # merge outputs with different scales after decoding bboxes\n            merged_bboxes = merge_aug_bboxes_3d(aug_bboxes, scale_img_metas,\n                                                self.pts_bbox_head.test_cfg)\n            return merged_bboxes\n        else:\n            for key in bbox_list[0].keys():\n                bbox_list[0][key] = bbox_list[0][key].to('cpu')\n            return bbox_list[0]\n\n    def aug_test(self, points, img_metas, imgs=None, rescale=False):\n        \"\"\"Test function with augmentaiton.\"\"\"\n        img_feats, pts_feats = self.extract_feats(points, img_metas, imgs)\n        bbox_list = dict()\n        if pts_feats and self.with_pts_bbox:\n            pts_bbox = self.aug_test_pts(pts_feats, img_metas, rescale)\n            bbox_list.update(pts_bbox=pts_bbox)\n        return [bbox_list]\n"
        }
    ]
}