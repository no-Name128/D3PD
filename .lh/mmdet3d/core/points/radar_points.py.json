{
    "sourceFile": "mmdet3d/core/points/radar_points.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1716534583068,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1716534583068,
            "name": "Commit-0",
            "content": "from mmdet3d.core.points.base_points import BasePoints\r\nimport torch\r\n\r\n\r\nclass RadarPoints(BasePoints):\r\n    \"\"\"Points of instances in LIDAR coordinates.\r\n\r\n    Args:\r\n        tensor (torch.Tensor | np.ndarray | list): a N x points_dim matrix.\r\n        points_dim (int): Number of the dimension of a point.\r\n            Each row is (x, y, z). Default to 3.\r\n        attribute_dims (dict): Dictionary to indicate the meaning of extra\r\n            dimension. Default to None.\r\n\r\n    Attributes:\r\n        tensor (torch.Tensor): Float matrix of N x points_dim.\r\n        points_dim (int): Integer indicating the dimension of a point.\r\n            Each row is (x, y, z, ...).\r\n        attribute_dims (bool): Dictionary to indicate the meaning of extra\r\n            dimension. Default to None.\r\n        rotation_axis (int): Default rotation axis for points rotation.\r\n    \"\"\"\r\n\r\n    def __init__(self, tensor, points_dim=3, attribute_dims=None):\r\n        super(RadarPoints, self).__init__(\r\n            tensor, points_dim=points_dim, attribute_dims=attribute_dims\r\n        )\r\n        self.rotation_axis = 2\r\n\r\n    def flip(self, bev_direction=\"horizontal\"):\r\n        \"\"\"Flip the boxes in BEV along given BEV direction.\"\"\"\r\n        if bev_direction == \"horizontal\":\r\n            self.tensor[:, 1] = -self.tensor[:, 1]\r\n            self.tensor[:, 4] = -self.tensor[:, 4]\r\n            # self.tensor[:, 5] = -self.tensor[:, 5]\r\n            # self.tensor[:, 7] = -self.tensor[:, 7]\r\n            # self.tensor[:, 9] = -self.tensor[:, 9]\r\n        elif bev_direction == \"vertical\":\r\n            self.tensor[:, 0] = -self.tensor[:, 0]\r\n            self.tensor[:, 3] = -self.tensor[:, 3]\r\n            # self.tensor[:, 4] = -self.tensor[:, 4]\r\n            # self.tensor[:, 6] = -self.tensor[:, 6]\r\n            # self.tensor[:, 8] = -self.tensor[:, 8]\r\n\r\n    def scale(self, scale_factor):\r\n        \"\"\"Scale the points with horizontal and vertical scaling factors.\r\n\r\n        Args:\r\n            scale_factors (float): Scale factors to scale the points.\r\n        \"\"\"\r\n        self.tensor[:, :3] *= scale_factor\r\n        self.tensor[:, 3:5] *= scale_factor\r\n\r\n    def rotate(self, rotation, axis=None):\r\n        \"\"\"Rotate points with the given rotation matrix or angle.\r\n\r\n        Args:\r\n            rotation (float, np.ndarray, torch.Tensor): Rotation matrix\r\n                or angle.\r\n            axis (int): Axis to rotate at. Defaults to None.\r\n        \"\"\"\r\n        if not isinstance(rotation, torch.Tensor):\r\n            rotation = self.tensor.new_tensor(rotation)\r\n        assert (\r\n            rotation.shape == torch.Size([3, 3]) or rotation.numel() == 1\r\n        ), f\"invalid rotation shape {rotation.shape}\"\r\n\r\n        if axis is None:\r\n            axis = self.rotation_axis\r\n\r\n        if rotation.numel() == 1:\r\n            rot_sin = torch.sin(rotation)\r\n            rot_cos = torch.cos(rotation)\r\n            if axis == 1:\r\n                rot_mat_T = rotation.new_tensor(\r\n                    [[rot_cos, 0, -rot_sin], [0, 1, 0], [rot_sin, 0, rot_cos]]\r\n                )  # xz rotation\r\n            elif axis == 2 or axis == -1:\r\n                rot_mat_T = rotation.new_tensor(\r\n                    [[rot_cos, -rot_sin, 0], [rot_sin, rot_cos, 0], [0, 0, 1]]\r\n                )  # xy rotation\r\n            elif axis == 0:\r\n                rot_mat_T = rotation.new_tensor(\r\n                    [[0, rot_cos, -rot_sin], [0, rot_sin, rot_cos], [1, 0, 0]]\r\n                )  # yz rotation\r\n            else:\r\n                raise ValueError(\"axis should in range\")\r\n            rot_mat_T = rot_mat_T.T\r\n        elif rotation.numel() == 9:\r\n            rot_mat_T = rotation\r\n        else:\r\n            raise NotImplementedError\r\n        self.tensor[:, :3] = self.tensor[:, :3] @ rot_mat_T\r\n\r\n        self.tensor[:, 3:5] = self.tensor[:, 3:5] @ rot_mat_T[:2, :2]\r\n        # self.tensor[:, 4:6] = self.tensor[:, 4:6] @ rot_mat_T[:2, :2]\r\n        # self.tensor[:, 6:8] = self.tensor[:, 6:8] @ rot_mat_T[:2, :2]\r\n        # self.tensor[:, 8:10] = self.tensor[:, 8:10] @ rot_mat_T[:2, :2]\r\n\r\n        return rot_mat_T\r\n\r\n    def in_range_bev(self, point_range):\r\n        \"\"\"Check whether the points are in the given range.\r\n\r\n        Args:\r\n            point_range (list | torch.Tensor): The range of point\r\n                in order of (x_min, y_min, x_max, y_max).\r\n\r\n        Returns:\r\n            torch.Tensor: Indicating whether each point is inside \\\r\n                the reference range.\r\n        \"\"\"\r\n        in_range_flags = (\r\n            (self.tensor[:, 0] > point_range[0])\r\n            & (self.tensor[:, 1] > point_range[1])\r\n            & (self.tensor[:, 0] < point_range[2])\r\n            & (self.tensor[:, 1] < point_range[3])\r\n        )\r\n        return in_range_flags\r\n\r\n    def convert_to(self, dst, rt_mat=None):\r\n        \"\"\"Convert self to ``dst`` mode.\r\n\r\n        Args:\r\n            dst (:obj:`CoordMode`): The target Point mode.\r\n            rt_mat (np.ndarray | torch.Tensor): The rotation and translation\r\n                matrix between different coordinates. Defaults to None.\r\n                The conversion from `src` coordinates to `dst` coordinates\r\n                usually comes along the change of sensors, e.g., from camera\r\n                to LiDAR. This requires a transformation matrix.\r\n\r\n        Returns:\r\n            :obj:`BasePoints`: The converted point of the same type \\\r\n                in the `dst` mode.\r\n        \"\"\"\r\n        from mmdet3d.core.bbox import Coord3DMode\r\n\r\n        return Coord3DMode.convert_point(\r\n            point=self, src=Coord3DMode.LIDAR, dst=dst, rt_mat=rt_mat\r\n        )\r\n"
        }
    ]
}